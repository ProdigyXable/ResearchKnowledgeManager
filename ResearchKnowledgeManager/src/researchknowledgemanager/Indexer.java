/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package researchknowledgemanager;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

/**
 * The Indexer class is contains all the necessary functions, data, etc... for
 * indexing files within the system. This class works exclusively for methods
 * and data in the ResearchKnowledgeManager class
 *
 * @see ResearchKnowledgeManager
 * @author Samuel Benton
 */
public class Indexer
{

    /**
     * @see ResearchKnowledgeManager#debug
     */
    boolean debug;

    /**
     * @see ResearchKnowledgeManager#lastOpened
     */
    long lastOpened;

    /**
     * Used to maintain a consistent and unified delimiter within the system
     */
    final String indexParseDelimiter = "|";

    /**
     * File name of the index file generated by the system
     */
    String indexFileName = "RKM_Manager_Index.txt";

    /**
     * Represents the index returned by indexfilesAll()
     *
     * @see #indexFilesAll(java.io.File,
     * researchknowledgemanager.ResearchKnowledgeManager)
     */
    String indexAllReturn = "";

    /**
     * Stores the list of new files found by indexFilesNew()
     *
     * @see #indexFilesNew(java.io.File,
     * researchknowledgemanager.ResearchKnowledgeManager)
     */
    String indexNewReturn = "";

    /**
     * FileWriter used to allow communication between methods in the Indexer
     * class
     */
    FileWriter indexFileWrite;

    UserInterface ui;

    /**
     * A set of pre-existing tag names used by the system.
     */
    public final static class TagName
    {

        static String READABLE = "Content Readable";

        static String UNREADABLE = "Content Unreadable";

        static String NONMICROSOFT = "Non Microsoft File";

        static String MICROSOFT = "Microsoft File";

        static String WORD = "Word Document";

        static String EXCEL = "Excel Document";

        static String POWERPOINT = "PowerPoint Presentation";

        static String HTML = "HTML Document";

        static String TEXT = "Plain Text File";

        static String XML = "XML File";

        static String PDF = "Adobe PDF";

        static String IMAGE = "Image File";

    }

    /**
     * Adds tags to a file based on the file's extension
     *
     * @param file The file (must be an actual file and not a folder) that will
     * be associated with new tags
     */
    void tagOnFileName(File file)
    {
        if (testReadableFileTypes(file))
        {

        }
        else
        {
            if (!ui.rm.Files.contains(new FileClass(file.toString(), ui.rm)))
            {
                ui.rm.addFileClass(new FileClass(file.toString(), ui.rm));
                ui.rm.Files.get(ui.rm.Files.size() - 1).addTag(TagName.UNREADABLE);

            }
            else
            {
                for (FileClass File : ui.rm.Files)
                {
                    if (File.toString().equals(file.toString()))
                    {
                        File.addTag(TagName.UNREADABLE);
                    }
                }
            }

        }

        fileTestIMAGE(file);
    }

    /**
     *
     * @param file The file (must be an actual file and not a folder) that will
     * be associated with new tags
     * @return <b>true</b> if the file returns one of the following: PDF, WORD,
     * EXCEL, PPT, TXT, XML, or HTML
     * <br><b>false</b> if the file is none of the above types
     */
    boolean testReadableFileTypes(File file)
    {
        return fileTestPDF(file) | fileTestWORD(file) | fileTestEXCEL(file) | fileTestPPT(file) | fileTestTXT(file) | fileTestHTML(file);
    }

    /**
     * Tags a file with the "IMAGE" tag if the file has an image extension
     *
     * @param file The file (must be an actual file and not a folder) that will
     * be associated with new tags
     */
    void fileTestIMAGE(File file)
    {
        String fileExtension = file.getName().split("\\.")[file.getName().split("\\.").length - 1];
        if (fileExtension.matches("svg|bmp|png|gif|tif(f?)|jp(e?)g"))
        {
            if (!ui.rm.Files.contains(new FileClass(file.toString(), ui.rm)))
            {
                ui.rm.addFileClass(new FileClass(file.toString(), ui.rm));
                ui.rm.Files.get(ui.rm.Files.size() - 1).addTag(TagName.IMAGE);
                return;

            }
            else
            {
                for (FileClass File : ui.rm.Files)
                {
                    if (File.toString().equals(file.toString()))
                    {
                        File.addTag(TagName.IMAGE);
                        return;
                    }
                }
            }
        }

        return;
    }

    /**
     * Tags a file with the "HTML" tag if the file has a HTML extension
     *
     * @param file The file (must be an actual file and not a folder) that will
     * be associated with new tags
     *
     * @return <b>true</b> is file is a html file.<br><b>false</b> otherwise
     */
    boolean fileTestHTML(File file)
    {
        String fileExtension = file.getName().split("\\.")[file.getName().split("\\.").length - 1];
        if (fileExtension.matches("htm.?|mht"))
        {
            if (!ui.rm.Files.contains(new FileClass(file.toString(), ui.rm)))
            {
                ui.rm.addFileClass(new FileClass(file.toString(), ui.rm));
                ui.rm.Files.get(ui.rm.Files.size() - 1).addTag(TagName.READABLE);
                ui.rm.Files.get(ui.rm.Files.size() - 1).addTag(TagName.NONMICROSOFT);
                ui.rm.Files.get(ui.rm.Files.size() - 1).addTag(TagName.HTML);
                return true;

            }
            else
            {
                for (FileClass File : ui.rm.Files)
                {
                    if (File.toString().equals(file.toString()))
                    {
                        File.addTag(TagName.READABLE);
                        File.addTag(TagName.NONMICROSOFT);
                        File.addTag(TagName.HTML);
                        return true;
                    }
                }
            }
        }

        return false;
    }

    /**
     * Tags a file with the "TEXT" tag if the file has a TEXT extension
     *
     * @param file The file (must be an actual file and not a folder) that will
     * be associated with new tags
     *
     * @return <b>true</b> is file is a text file.<br><b>false</b> otherwise
     */
    boolean fileTestTXT(File file)
    {
        String fileExtension = file.getName().split("\\.")[file.getName().split("\\.").length - 1];
        if (fileExtension.matches("txt|rtf"))
        {
            if (!ui.rm.Files.contains(new FileClass(file.toString(), ui.rm)))
            {
                ui.rm.addFileClass(new FileClass(file.toString(), ui.rm));
                ui.rm.Files.get(ui.rm.Files.size() - 1).addTag(TagName.READABLE);
                ui.rm.Files.get(ui.rm.Files.size() - 1).addTag(TagName.NONMICROSOFT);
                ui.rm.Files.get(ui.rm.Files.size() - 1).addTag(TagName.TEXT);
                return true;

            }
            else
            {
                for (FileClass File : ui.rm.Files)
                {
                    if (File.toString().equals(file.toString()))
                    {
                        File.addTag(TagName.READABLE);
                        File.addTag(TagName.NONMICROSOFT);
                        File.addTag(TagName.TEXT);
                        return true;
                    }
                }
            }
        }

        return false;
    }

    /**
     * Tags a file with the "PPT" tag if the file has a PPT extension
     *
     * @param file The file (must be an actual file and not a folder) that will
     * be associated with new tags
     *
     * @return <b>true</b> is file is a PPT file.<br><b>false</b> otherwise
     */
    boolean fileTestPPT(File file)
    {
        /**
         * Tags a file with the "PPT" tag if the file has a PPT extension
         *
         * @param file The file (must be an actual file and not a folder) that
         * will be associated with new tags
         *
         * @return <b>true</b> is file is a PPT file.<br><b>false</b> otherwise
         */
        String fileExtension = file.getName().split("\\.")[file.getName().split("\\.").length - 1];
        if (fileExtension.matches("ppt.?|pot.*"))
        {
            if (!ui.rm.Files.contains(new FileClass(file.toString(), ui.rm)))
            {
                ui.rm.addFileClass(new FileClass(file.toString(), ui.rm));
                ui.rm.Files.get(ui.rm.Files.size() - 1).addTag(TagName.READABLE);
                ui.rm.Files.get(ui.rm.Files.size() - 1).addTag(TagName.MICROSOFT);
                ui.rm.Files.get(ui.rm.Files.size() - 1).addTag(TagName.POWERPOINT);
                return true;

            }
            else
            {
                for (FileClass File : ui.rm.Files)
                {
                    if (File.toString().equals(file.toString()))
                    {
                        File.addTag(TagName.READABLE);
                        File.addTag(TagName.MICROSOFT);
                        File.addTag(TagName.POWERPOINT);
                        return true;
                    }
                }
            }
        }

        return false;
    }

    /**
     * Tags a file with the "EXCEL" tag if the file has an EXCEL extension
     *
     * @param file The file (must be an actual file and not a folder) that will
     * be associated with new tags
     *
     * @return <b>true</b> is file is an EXCEL file.<br><b>false</b> otherwise
     */
    boolean fileTestEXCEL(File file)
    {
        String fileExtension = file.getName().split("\\.")[file.getName().split("\\.").length - 1];
        if (fileExtension.matches("xls.?|xl.?"))
        {
            if (!ui.rm.Files.contains(new FileClass(file.toString(), ui.rm)))
            {
                ui.rm.addFileClass(new FileClass(file.toString(), ui.rm));
                ui.rm.Files.get(ui.rm.Files.size() - 1).addTag(TagName.READABLE);
                ui.rm.Files.get(ui.rm.Files.size() - 1).addTag(TagName.MICROSOFT);
                ui.rm.Files.get(ui.rm.Files.size() - 1).addTag(TagName.EXCEL);
                return true;

            }
            else
            {
                for (FileClass File : ui.rm.Files)
                {
                    if (File.toString().equals(file.toString()))
                    {
                        File.addTag(TagName.READABLE);
                        File.addTag(TagName.MICROSOFT);
                        File.addTag(TagName.EXCEL);
                        return true;
                    }
                }
            }
        }

        return false;
    }

    /**
     * Tags a file with the "WORD" tag if the file has a WORD extension
     *
     * @param file The file (must be an actual file and not a folder) that will
     * be associated with new tags
     *
     * @return <b>true</b> is file is a WORD file.<br><b>false</b> otherwise
     */
    boolean fileTestWORD(File file)
    {
        String fileExtension = file.getName().split("\\.")[file.getName().split("\\.").length - 1];
        if (fileExtension.matches("doc.?"))
        {
            if (!ui.rm.Files.contains(new FileClass(file.toString(), ui.rm)))
            {
                ui.rm.addFileClass(new FileClass(file.toString(), ui.rm));
                ui.rm.Files.get(ui.rm.Files.size() - 1).addTag(TagName.READABLE);
                ui.rm.Files.get(ui.rm.Files.size() - 1).addTag(TagName.MICROSOFT);
                ui.rm.Files.get(ui.rm.Files.size() - 1).addTag(TagName.WORD);
                return true;

            }
            else
            {
                for (FileClass File : ui.rm.Files)
                {
                    if (File.toString().equals(file.toString()))
                    {
                        File.addTag(TagName.READABLE);
                        File.addTag(TagName.MICROSOFT);
                        File.addTag(TagName.WORD);
                        return true;
                    }
                }
            }
        }

        return false;
    }

    /**
     * Tags a file with the "PDF" tag if the file has a PDF extension
     *
     * @param file The file (must be an actual file and not a folder) that will
     * be associated with new tags
     *
     * @return <b>true</b> is file is a PDF file.<br><b>false</b> otherwise
     */
    boolean fileTestPDF(File file)
    {
        String fileExtension = file.getName().split("\\.")[file.getName().split("\\.").length - 1];
        if (fileExtension.equals("pdf"))
        {
            if (!ui.rm.Files.contains(new FileClass(file.toString(), ui.rm)))
            {
                ui.rm.addFileClass(new FileClass(file.toString(), ui.rm));
                ui.rm.Files.get(ui.rm.Files.size() - 1).addTag(TagName.READABLE);
                ui.rm.Files.get(ui.rm.Files.size() - 1).addTag(TagName.NONMICROSOFT);
                ui.rm.Files.get(ui.rm.Files.size() - 1).addTag(TagName.PDF);

                return true;

            }
            else
            {
                for (FileClass File : ui.rm.Files)
                {
                    if (File.toString().equals(file.toString()))
                    {
                        File.addTag(TagName.READABLE);
                        File.addTag(TagName.NONMICROSOFT);
                        File.addTag(TagName.PDF);
                        return true;
                    }
                }
            }
        }

        return false;
    }

    /**
     * Initializes all the data necessary for an instance of Indexer
     *
     * @param debugFlag Defines the debug status of the Indexer. Exactly the
     * same as debug in ResearchKnowlegeManager
     * @param lastModified Defines the lastModified of the indexer. Exactly the
     * same as lastOpened in ResearchKnowledgeManager
     * @param ui An instance of the User Interface
     * @see ResearchKnowledgeManager#debug
     * @see UserInterface
     * @see ResearchKnowledgeManager#lastOpened
     */
    Indexer(boolean debugFlag, long lastModified, UserInterface ui)
    {
        this.debug = debugFlag;
        this.lastOpened = lastModified;
        this.ui = ui;
    }

    /**
     * Recursively counts the number of files (excluding folders) within a
     * directory. Explores every subdirectory in the main directory
     *
     * @param file The folder (not file, but an actual folder) whose children
     * will be counted
     * @return The number of files (not including folders) in the folder
     */
    int computeMaxFolderChild(File file)
    {

        File[] buffer = file.listFiles();
        int returnValue = 0;

        ui.progressBar.setString("Checking " + file);

        // Executes if something is wrong with file, possible a hidden folder or folder with special permissions
        if (buffer == null)
        {
            if (debug)
            {
                System.err.println("File in question is " + file);
                System.err.println("File can Read = " + file.canRead());
                System.err.println("File can Execute = " + file.canExecute());
                System.err.println("File can Write = " + file.canWrite());
                System.err.println("File is hidden = " + file.isHidden());
                System.err.println("There was a problem with the folder specified! -> " + file.toString());
            }
            return 0;
        }
        else
        {
            for (File data : buffer)
            {
                synchronized (ui.executingThread)
                {
                    if (this.ui.rm.actionStatus == ResearchKnowledgeManager.activeState.PAUSED)
                    {
                        try
                        {
                            ui.executingThread.wait();
                        }
                        catch (InterruptedException ex)
                        {
                            System.err.println("Interrupt exception encountered!!!");
                        }
                    }
                }
                if (!data.isHidden())
                {
                    if (data.isDirectory())
                    {
                        returnValue += computeMaxFolderChild(data);
                    }
                    else
                    {
                        returnValue++;

                    }
                }

            }
            return returnValue;
        }
    }

    /**
     * Creates an index of all the files (and files in subdirectories) within
     * the path parameter
     *
     * @param path The folder (not file, but an actual folder) whose children
     * files will be index
     * @param rm An instance of ResearchKnowledgeManager
     * @return A string with containing each file (not folder, but actual files)
     * delimited by indexParseDelimiter
     * @see #indexParseDelimiter
     * @see ResearchKnowledgeManager#ResearchKnowledgeManager()
     */
    String indexFilesAll(File path, ResearchKnowledgeManager rm)
    {
        File[] result = path.listFiles();
        String validResults = "";

        if (result == null)
        {
            if (this.debug)
            {
                System.err.println("Input \"path\" parameter for indexFiles() is not a valid directory! --- " + path.toString());
            }

            rm.ui.newMessage(path.toString() + " is not a valid directory path!");
            rm.ui.newMessage("Exiting out of the current action...");
            rm.ui.newMessage(rm.lineSeparator);

        }
        else
        {
            // Iterates through the Files in the File[] result array
            for (int i = 0; i < result.length; i++)
            {

                // Used to allow the user to pause/resume mid function
                synchronized (ui.executingThread)
                {
                    if (rm.actionStatus == ResearchKnowledgeManager.activeState.PAUSED)
                    {
                        try
                        {
                            ui.executingThread.wait();
                        }
                        catch (InterruptedException ex)
                        {
                            System.err.println("Interrupt exception encountered!!!");
                        }
                    }
                }
                rm.ui.progressBar.setValue(rm.ui.progressBar.getValue() + 1);

                // Outputs an error if path is not a folder
                if (!result[i].isDirectory())
                {
                    if (this.debug)
                    {
                        System.out.println("File found -> " + result[i].toString());
                    }

                    // Files can be preemptively put into tags based on their file names here
                    // We can also search the content of files here if needed
                    tagOnFileName(result[i]);
                    validResults += result[i].toString() + this.indexParseDelimiter;
                }
                else
                {
                    // Recursively iterate all the files in a folder
                    validResults += this.indexFilesAll(result[i], rm);
                }
            }
        }

        return validResults;
    }

    /**
     * Creates an index of all the files (and files in subdirectories) within
     * the path parameter whose last modified timestamp is greater than the
     * system's lastOpened value
     *
     * @param path The folder (not file, but an actual folder) whose children
     * files will be index
     * @param rm An instance of ResearchKnowledgeManager
     * @return A string with containing each file (not folder, but actual files)
     * delimited by indexParseDelimiter
     * @see #indexParseDelimiter
     * @see ResearchKnowledgeManager#ResearchKnowledgeManager()
     */
    String indexFilesNew(File path, ResearchKnowledgeManager rm)
    {
        String validResults = "";
        File[] potentialNew = path.listFiles();

        if (potentialNew == null)
        {
            if (this.debug)
            {
                System.err.println("Input \"path\" parameter for indexFiles() is not a valid directory! --- " + path.toString());
            }

            rm.ui.newMessage(path.toString() + " is not a valid directory path!");
            rm.ui.newMessage("Exiting out of the current action...");
            rm.ui.newMessage(rm.lineSeparator);

        }
        else
        {

            //Loop to detect newly modified files and add them into the file vector
            for (int i = 0; i < potentialNew.length; i++)
            {

                // Used to allow the user to pause/resume mid function
                synchronized (ui.executingThread)
                {
                    if (rm.actionStatus == ResearchKnowledgeManager.activeState.PAUSED)
                    {
                        try
                        {
                            ui.executingThread.wait();
                        }
                        catch (InterruptedException ex)
                        {
                            System.err.println("Interrupt exception encountered!!!");
                        }
                    }
                }

                rm.ui.progressBar.setValue(rm.ui.progressBar.getValue() + 1);
                if (!potentialNew[i].isDirectory())
                {
                    if (potentialNew[i].lastModified() > this.lastOpened)
                    {
                        validResults += potentialNew[i].toString() + this.indexParseDelimiter;

                        // Files can be preemptively put into tags based on their file names here
                        // We can also search the content of files here if needed
                        tagOnFileName(potentialNew[i]);
                        rm.ui.newMessage("New file detected! ->" + potentialNew[i].toString());
                    }
                }
                else
                {
                    if (potentialNew[i].isDirectory())
                    {
                        validResults += this.indexFilesNew(potentialNew[i], rm) + indexParseDelimiter;
                    }
                }
            }
        }

        return validResults;
    }

    /**
     * Locally creates a new file and saves the index currently in the system
     * (indexAllReturn).
     *
     * @param saveDirectory The directory (not file but an actual folder) that
     * the index is saved to
     * @return <b>true</b> if the save succeeds.<br><b>false</b> if the save
     * fails in some way.
     *
     * @see #indexAllReturn
     * @see #saveIndexAll(java.lang.String[], java.io.File)
     */
    boolean saveIndexAll(File saveDirectory)
    {
        return saveIndexAll(this.indexAllReturn, saveDirectory);
    }

    /**
     * Parses "files" with a delimiter, locally creates a new file and saves
     * this parsed index
     *
     * @param files A list of files delimited by indexParseDelimiter
     * @param saveDirectory The directory (not file but an actual folder) that
     * the index is saved to
     * @return <b>true</b> if the save succeeds.<br><b>false</b> if the save
     * fails in some way.
     *
     * @see #indexParseDelimiter
     * @see #saveIndexAll(java.lang.String[], java.io.File)
     */
    boolean saveIndexAll(String files, File saveDirectory)
    {
        return saveIndexAll(files.split("\\" + this.indexParseDelimiter), saveDirectory);
    }

    /**
     * Creates a new file and locally saves the contents of "fileList" adding
     * indexParseDelimiter as a delimiter
     *
     * @param fileList The set of files which will make up the system's index
     * @param saveDirectory The directory (not file but an actual folder) that
     * the index is saved to
     * @return <b>true</b> if the save succeeds.<br><b>false</b> if the save
     * fails in some way.
     * @see #indexParseDelimiter
     *
     */
    boolean saveIndexAll(String[] fileList, File saveDirectory)
    {
        try
        {
            String filename = saveDirectory.toString() + "\\" + indexFileName;
            indexFileWrite = new FileWriter(filename, false);

            for (String fileList1 : fileList)
            {

                this.indexFileWrite.write(fileList1.toLowerCase().trim() + this.indexParseDelimiter);
            }

            ui.newMessage("Indexing of all files completed");
            ui.newMessage(ui.rm.lineSeparator);

            this.indexFileWrite.close();
            return true;

        }
        catch (IOException ex)
        {

            ui.newMessage("An error has occured when trying to add files to the system's index");
            if (debug)
            {
                System.err.println(ex.getMessage());
            }

            ui.newMessage(ui.rm.lineSeparator);

            this.indexFileWrite = null;
            return false;
        }

    }

    /**
     * Locally creates a new file and appends data to the index currently in teh
     * system (indexNewReturn).
     *
     * @param saveDirectory The directory (not file but an actual folder) that
     * the index is saved to
     * @return <b>true</b> if the save succeeds.<br><b>false</b> if the save
     * fails in some way.
     *
     * @see #indexNewReturn
     * @see #saveIndexNew(java.lang.String[], java.io.File)
     */
    boolean saveIndexNew(File saveDirectory)
    {
        return saveIndexNew(this.indexNewReturn, saveDirectory);
    }

    /**
     * Parses "files" with a delimiter, locally creates a new file and appends
     * this parsed index to the index currently in the system
     *
     * @param files A list of files delimited by indexParseDelimiter
     * @param saveDirectory The directory (not file but an actual folder) that
     * the index is saved to
     * @return <b>true</b> if the save succeeds.<br><b>false</b> if the save
     * fails in some way.
     *
     * @see #indexParseDelimiter
     * @see #saveIndexNew(java.lang.String[], java.io.File)
     */
    boolean saveIndexNew(String files, File saveDirectory)
    {
        return saveIndexNew(files.split("\\" + this.indexParseDelimiter), saveDirectory);
    }

    /**
     * Creates a new file and locally appends the contents of "fileList" adding
     * indexParseDelimiter as a delimiter
     *
     * @param fileList The set of strings which will be added to the index
     * @param saveDirectory The directory (not file but an actual folder) that
     * the index is saved to
     * @return <b>true</b> if the save succeeds.<br><b>false</b> if the save
     * fails in some way.
     * @see #indexParseDelimiter
     *
     */
    boolean saveIndexNew(String[] fileList, File saveDirectory)
    {
        try
        {
            indexFileWrite = new FileWriter(saveDirectory.toString() + "\\" + indexFileName, true);

            for (String fileList1 : fileList)
            {
                this.indexFileWrite.write(fileList1 + this.indexParseDelimiter);
            }

            ui.newMessage("Indexing of new files completed!");
            ui.newMessage(ui.rm.lineSeparator);

            this.indexFileWrite.close();
            return true;
        }
        catch (IOException ex)
        {

            ui.newMessage("An error has occured when trying to add new files to the system's index");
            if (debug)
            {
                System.err.println(ex.getMessage());
            }
            ui.newMessage(ui.rm.lineSeparator);

            this.indexFileWrite = null;
            return false;
        }

    }

}
